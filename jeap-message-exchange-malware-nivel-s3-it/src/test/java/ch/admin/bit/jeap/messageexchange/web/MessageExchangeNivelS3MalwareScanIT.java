package ch.admin.bit.jeap.messageexchange.web;

import ch.admin.bit.jeap.messageexchange.malware.api.MalwareScanResult;
import ch.admin.bit.jeap.messaging.kafka.test.KafkaIntegrationTestBase;
import ch.admin.bit.jeap.security.resource.semanticAuthentication.SemanticApplicationRole;
import ch.admin.bit.jeap.security.resource.token.JeapAuthenticationToken;
import ch.admin.bit.jeap.security.test.resource.JeapAuthenticationTestTokenBuilder;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.awspring.cloud.sqs.operations.SqsTemplate;
import lombok.SneakyThrows;
import org.awaitility.Awaitility;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Profile;
import org.springframework.http.MediaType;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.web.servlet.MockMvc;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.containers.localstack.LocalStackContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.http.nio.netty.NettyNioAsyncHttpClient;
import software.amazon.awssdk.http.nio.netty.ProxyConfiguration;
import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.CreateBucketRequest;
import software.amazon.awssdk.services.sqs.SqsAsyncClient;

import java.time.Duration;
import java.util.UUID;

import static ch.admin.bit.jeap.messageexchange.web.api.HeaderNames.HEADER_BP_ID;
import static ch.admin.bit.jeap.messageexchange.web.api.HeaderNames.HEADER_MESSAGE_TYPE;
import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.authentication;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(
        webEnvironment = SpringBootTest.WebEnvironment.MOCK,
        properties = {
                "spring.application.name=junit",
                "jeap.messageexchange.kafka.topic.message-received=message-received",
                "jeap.messaging.kafka.error-topic-name=error",
                "jeap.messaging.kafka.system-name=test",
                "jeap.messaging.kafka.service-name=test",
                "jeap.messageexchange.objectstorage.connection.bucket-name-partner=test-bucket-partner",
                "jeap.messageexchange.objectstorage.connection.bucket-name-internal=test-bucket-internal",
                "jeap.messageexchange.api.max-request-body-size-in-bytes=100"
        })
@Testcontainers
@AutoConfigureMockMvc
@ActiveProfiles("nivel-s3-malwarescan-it") // prevent other tests from picking up this test's configuration
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
@Import({MessageExchangeNivelS3MalwareScanIT.TestConfig.class})
class MessageExchangeNivelS3MalwareScanIT extends KafkaIntegrationTestBase {

    private static final String QUEUE_NAME = "nivel-s3-malwarescan-queue";
    private static final UUID MESSAGE_ID = UUID.randomUUID();
    private static final String BP_ID = "myBpID";
    private static final String MESSAGE_TYPE = "myMessageType";
    private static final String XML_CONTENT = """
                                              <content>
                                                  <test>test</test>
                                              </content>
                                              """;

    private static final SemanticApplicationRole B2B_MESSAGE_IN_WRITE = SemanticApplicationRole.builder()
            .system("junit")
            .resource("b2bmessagein")
            .operation("write")
            .build();
    private static final SemanticApplicationRole B2B_MESSAGE_IN_READ = SemanticApplicationRole.builder()
            .system("junit")
            .resource("b2bmessagein")
            .operation("read")
            .build();

    @Container // @ServiceConnection does not seem to support a local stack container with two services
    private static final LocalStackContainer LOCAL_STACK = createLocalStackContainer();

    @Container
    @ServiceConnection
    private static final PostgreSQLContainer<?> POSTGRES = new PostgreSQLContainer<>("postgres:15-alpine");

    @Autowired
    private MockMvc mvc;

    @Autowired
    @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection")
    private SqsTemplate sqsTemplate;

    @Value("${jeap.messageexchange.malwarescan.nivel-s3.sqs-queue-url}")
    private String sqsQueueUrl;

    @Autowired
    private TestMalwareScanTrigger testMalwareScanTrigger;

    @Autowired
    private TestEventConsumer testEventConsumer;

    private static LocalStackContainer createLocalStackContainer() {
        return new LocalStackContainer(DockerImageName.parse("localstack/localstack:4.10.0")
                .asCompatibleSubstituteFor("localstack/localstack"))
                .withServices(LocalStackContainer.Service.S3, LocalStackContainer.Service.SQS)
                // Disable localstack features that require an internet connection
                .withEnv("DISABLE_EVENTS", "1")
                .withEnv("SKIP_INFRA_DOWNLOADS", "1")
                .withEnv("SKIP_SSL_CERT_DOWNLOAD", "1");
    }

    @DynamicPropertySource
    static void dynamicProperties(DynamicPropertyRegistry registry) {
        // S3 configuration
        registry.add("jeap.messageexchange.objectstorage.connection.region", LOCAL_STACK::getRegion);
        registry.add("jeap.messageexchange.objectstorage.connection.access-key", LOCAL_STACK::getAccessKey);
        registry.add("jeap.messageexchange.objectstorage.connection.secret-key", LOCAL_STACK::getSecretKey);
        registry.add("jeap.messageexchange.objectstorage.connection.accessUrl", () -> LOCAL_STACK.getEndpointOverride(LocalStackContainer.Service.S3));
        // Spring Cloud AWS SQS configuration
        registry.add("spring.cloud.aws.region.static", LOCAL_STACK::getRegion);
        registry.add("spring.cloud.aws.credentials.access-key", LOCAL_STACK::getAccessKey);
        registry.add("spring.cloud.aws.credentials.secret-key", LOCAL_STACK::getSecretKey);
        registry.add("spring.cloud.aws.sqs.endpoint", () -> LOCAL_STACK.getEndpointOverride(LocalStackContainer.Service.SQS).toString());
        // SQS queue
        registry.add("jeap.messageexchange.malwarescan.nivel-s3.sqs-queue-url", () -> QUEUE_NAME);
    }

    @BeforeAll
    @SneakyThrows
    static void initializeLocalStack() {
        createBuckets();
        LOCAL_STACK.execInContainer("awslocal", "sqs", "create-queue", "--queue-name", QUEUE_NAME);
    }

    private static void createBuckets() {
        S3Client s3Client = createS3Client(LOCAL_STACK);
        CreateBucketRequest createPartnerBucketRequest = CreateBucketRequest.builder()
                .bucket("test-bucket-partner")
                .build();
        s3Client.createBucket(createPartnerBucketRequest);

        CreateBucketRequest createInternalBucketRequest = CreateBucketRequest.builder()
                .bucket("test-bucket-internal")
                .build();
        s3Client.createBucket(createInternalBucketRequest);
    }

    @BeforeEach
    void setup() {
        testMalwareScanTrigger.clear();
    }

    @Test
    void putMessageFromPartner_WhenMalwareScanSuccessful_thenMessageRetrievable() throws Exception {

        // Put a message via the partner API. This should trigger a malware scan.
        putPartnerMessage();

        // Simulate a successful malware scan with no threats found by sending a matching malware scan result message to
        // the SQS queue using the key and bucket name used in the scan trigger.
        assertThat(testMalwareScanTrigger.getTriggers()).hasSize(1);
        String key = testMalwareScanTrigger.getTriggers().getFirst().key();
        String bucket = testMalwareScanTrigger.getTriggers().getFirst().bucket();
        sendMalwareScanResultSqsMessage(key, bucket, MalwareScanResult.NO_THREATS_FOUND);

        // When the partner message was saved we should receive the B2BMessageReceivedEvent
        Awaitility.await()
                .atMost(Duration.ofSeconds(30))
                .until(() -> testEventConsumer.hasMessageWithIdempotenceId(MESSAGE_ID));

        // When the scan reported no threat the partner message should be retrievable via the internal API
        JeapAuthenticationToken authentication = createAuthenticationForUserRoles(B2B_MESSAGE_IN_READ);
        mvc.perform(get("/api/internal/v2/messages/" + MESSAGE_ID)
                        .with(authentication(authentication))
                        .contentType(MediaType.APPLICATION_XML))
                .andExpect(status().isOk());
    }

    @Test
    void putMessageFromPartner_WhenMalwareScanFindsThreat_thenMessageNotRetrievable() throws Exception {

        // Put a message via the partner API. This should trigger a malware scan.
        putPartnerMessage();

        // Simulate a successful malware scan with a threat found by sending a matching malware scan result message to
        // the SQS queue using the key and bucket name used in the scan trigger.
        assertThat(testMalwareScanTrigger.getTriggers()).hasSize(1);
        String key = testMalwareScanTrigger.getTriggers().getFirst().key();
        String bucket = testMalwareScanTrigger.getTriggers().getFirst().bucket();
        sendMalwareScanResultSqsMessage(key, bucket, MalwareScanResult.THREATS_FOUND);

        // When the partner message was saved we should receive the B2BMessageReceivedEvent
        Awaitility.await()
                .atMost(Duration.ofSeconds(30))
                .until(() -> testEventConsumer.hasMessageWithIdempotenceId(MESSAGE_ID));

        // When the scan reported a threat the partner message should not be retrievable via the internal API
        JeapAuthenticationToken authentication = createAuthenticationForUserRoles(B2B_MESSAGE_IN_READ);
        mvc.perform(get("/api/internal/v2/messages/" + MESSAGE_ID)
                        .with(authentication(authentication))
                        .contentType(MediaType.APPLICATION_XML))
                .andExpect(status().isForbidden());
    }

    private void putPartnerMessage() throws Exception {
        JeapAuthenticationToken authentication = createAuthenticationForBpRoles(BP_ID, B2B_MESSAGE_IN_WRITE);
        mvc.perform(put("/api/partner/v3/messages/" + MESSAGE_ID)
                        .with(authentication(authentication))
                        .contentType(MediaType.APPLICATION_XML)
                        .header(HEADER_BP_ID, BP_ID)
                        .header(HEADER_MESSAGE_TYPE, MESSAGE_TYPE)
                        .content(XML_CONTENT))
                .andExpect(status().isCreated());
    }

    @SneakyThrows
    private void sendMalwareScanResultSqsMessage(String key, String bucket, MalwareScanResult scanResult) {
        NivelS3MalwareScanResultMessage message = NivelS3MalwareScanResultMessage.builder()
                .objectKey(key)
                .bucketName(bucket)
                .scanResult(scanResult)
                 // The SQS message from Nivel contains more fields than we currently use.
                .objectVersionId("unused-version-id")
                .eTag("unused-etag")
                .resourceType("S3_OBJECT")
                .build();
        ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
        String jsonMessage = objectMapper.writeValueAsString(message);
        sqsTemplate.send(sqsQueueUrl, jsonMessage);
    }

    // Create an S3 client that connects to local stack and ignores any proxy settings from the environment
    private static S3Client createS3Client(LocalStackContainer localStack) {
        return S3Client.builder()
                .endpointOverride(localStack.getEndpointOverride(LocalStackContainer.Service.S3))
                .region(Region.of(localStack.getRegion()))
                .credentialsProvider(StaticCredentialsProvider.create(
                        AwsBasicCredentials.create(localStack.getAccessKey(), localStack.getSecretKey())))
                .httpClientBuilder(UrlConnectionHttpClient.builder()
                        .proxyConfiguration(software.amazon.awssdk.http.urlconnection.ProxyConfiguration.builder()
                                .useSystemPropertyValues(false)
                                .useEnvironmentVariablesValues(false)
                                .build()))
                .build();
    }

    private static JeapAuthenticationToken createAuthenticationForBpRoles(String bpId, SemanticApplicationRole... roles)  {
        return JeapAuthenticationTestTokenBuilder.create().withBusinessPartnerRoles(bpId, roles).build();
    }

    private static JeapAuthenticationToken createAuthenticationForUserRoles(SemanticApplicationRole... userroles)  {
        return JeapAuthenticationTestTokenBuilder.create().withUserRoles(userroles).build();
    }

    @TestConfiguration
    @Profile("nivel-s3-malwarescan-it")
    static class TestConfig {
        @Bean
        public TestMalwareScanTrigger testMalwareScanTrigger() {
            return new TestMalwareScanTrigger();
        }
        @Bean
        public TestEventConsumer testEventConsumer() {
            return new TestEventConsumer();
        }
        // Provide an SQS async client that connects to local stack and ignores any proxy settings from the environment
        @Bean
        public SqsAsyncClient sqsAsyncClient() {
            return SqsAsyncClient.builder()
                    .endpointOverride(LOCAL_STACK.getEndpointOverride(LocalStackContainer.Service.SQS))
                    .region(Region.of(LOCAL_STACK.getRegion()))
                    .credentialsProvider(StaticCredentialsProvider.create(
                            AwsBasicCredentials.create(LOCAL_STACK.getAccessKey(), LOCAL_STACK.getSecretKey())))
                    .httpClient(NettyNioAsyncHttpClient.builder()
                            .proxyConfiguration(ProxyConfiguration.builder()
                                    .useEnvironmentVariableValues(false)
                                    .useSystemPropertyValues(false)
                                    .build())
                            .build())
                    .build();
        }
    }

}
